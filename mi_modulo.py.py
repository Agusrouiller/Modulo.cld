# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15Al4bOL9lDjbf5S5yo5_BgLqTGCE7IWT
"""

import numpy as np
import matplotlib.pyplot as plt
import statsmodels.api as sm
from scipy.stats import norm, expon, chi2,t, uniform, stats


class AnalisisDescriptivo:
  """
  Clase para realizar análisis descriptivo de una muestra de datos.
  Permite construir histogramas, estimar densidades mediante núcleos (kernel),
  calcular el error cuadrático medio (ECM) y realizar gráficos QQ.
  """
  def __init__(self, datos):
    self.datos = np.array(datos)

  def genera_histograma(self, h):
    """Genera los intervalos y calcula las frecuencias relativas del histograma."""
    bins = np.arange(min(self.datos), max(self.datos) + h, h)
    fr_absolutas = np.zeros(len(bins) - 1)

    for dato in self.datos:
      for i in range(len(bins) - 1):
        if bins[i] <= dato < bins[i + 1]:
          fr_absolutas[i] += 1
          break

    frecuencias_intervalos = (fr_absolutas / len(self.datos)) / h
    return bins, frecuencias_intervalos

  def evalua_histograma(self, h, x):
    """Evalúa el histograma en puntos dados."""
    bins, frec = self.genera_histograma(h)
    res = np.zeros(len(x))

    for i, valor in enumerate(x):
      for j in range(len(bins) - 1):
        if bins[j] <= valor < bins[j + 1]:
          res[i] = frec[j]
          break

    return res # Retorna frecuencia relativa estimada en cada punto de x.

  # Estimación de densidad con kernels / núcleos
  def kernel_gaussiano(self, u):
    return (1 / np.sqrt(2 * np.pi)) * np.exp(-0.5 * u**2)

  def kernel_uniforme(self, u):
    return np.where(np.abs(u) <= 0.5, 1, 0)

  def epanechnikov(self, u):
    return 3/4 * (1 - u**2) * (np.abs(u) <= 1)

  def triangular(self, u):
    return (1 + u) * (u >= -1) * (u < 0) + (1 - u) * (u >= 0) * (u <= 1)

  def densidad_nucleo(self, x, h, kernel):
    """Calcula la estimación de densidad con diferentes kernels."""
    n = len(self.datos)
    density = np.zeros_like(x)

    for i, xi in enumerate(x):
      u = (self.datos - xi) / h  # Escalamiento de los datos
      if kernel == "uniforme":
        density[i] = np.sum(self.kernel_uniforme(u)) / (n * h)
      elif kernel == "gaussiano":
        density[i] = np.sum(self.kernel_gaussiano(u)) / (n * h)
      elif kernel == "epanechnikov":
        density[i] = np.sum(self.epanechnikov(u)) / (n * h)
      elif kernel == "triangular":
        density[i] = np.sum(self.triangular(u)) / (n * h)

    return density #Densidad estimada en cada punto de x.

  def calcular_ecm(self, x, h, kernel, densidad_teorica): #calcula el ecm para un h especifico
    """Calcula el ECM entre la densidad estimada con núcleo y la densidad teórica."""
    if kernel == "histograma":
      densidad_estimada = self.evalua_histograma(h, x)
      return np.mean((densidad_estimada - densidad_teorica) ** 2)
    else:
      densidad_estimada = self.densidad_nucleo(x, h, kernel)
      return np.mean((densidad_estimada - densidad_teorica) ** 2)

  def buscar_h_optimo(self, x, h_values, kernel, densidad_teorica):  #busca h otimo y me da el ecm para cada valor de h
    """Busca el h que minimiza el ECM entre la densidad estimada y la teórica."""
    errores = [self.calcular_ecm(x, h, kernel, densidad_teorica) for h in h_values]
    h_optimo = h_values[np.argmin(errores)]
    return h_optimo, errores

  #Estimación de QQ plot
  def miqqplot(self):
    x = np.array(self.datos)
    x_ord = np.sort(x)
    n = len(x_ord)

    # Establecer los cuantiles teóricos de la distribución normal estándar
    p_teoricos = np.arange(1, (n+1)) / (n+1)
    cuantiles_teoricos = norm.ppf(p_teoricos)

    #datos estandarizados, cuantil muestral
    media_x_ord = np.mean(x_ord)
    desvio_x_ord = np.std(x_ord)
    x_ord_s = (x_ord - media_x_ord)/desvio_x_ord

    plt.scatter(cuantiles_teoricos, x_ord_s, label="Cuantiles muestrales")
    plt.plot(cuantiles_teoricos, cuantiles_teoricos, color="red", label="Recta identidad (y=x)")

    plt.xlabel("Cuantiles teóricos (Normal estándar)")
    plt.ylabel("Cuantiles muestrales")
    plt.title("Gráfico QQ - Comparación de cuantiles")
    plt.legend()
    plt.grid(True)
    plt.show()
  pass


class GeneradoraDeDatos:
  """
  Clase para generar datos simulados de distintas distribuciones teóricas
  (Normal, Exponencial, Chi-cuadrado, t de Student, Uniforme y una distribución BS).
  Devuelve tanto los datos simulados como la función de densidad teórica asociada.
  """
  def __init__(self, n):
    self.n = n

  def normal(self, media=0, desviacion=1):
    """Genera datos normales y devuelve también la densidad teórica."""
    datos = np.random.normal(media, desviacion, size=self.n)
    def densidad(x): return norm.pdf(x, media, desviacion)
    return datos, densidad

  def exponencial(self, beta=1):
    """Genera datos exponenciales y devuelve también la densidad teórica."""
    datos = np.random.exponential(scale=beta, size=self.n)
    def densidad(x): return (1/beta) * np.exp(-x/beta) * (x >= 0)
    return datos, densidad

  def chi_cuadrado(self, df):
    """Genera datos chi-cuadrado y devuelve también la densidad teórica."""
    datos = np.random.chisquare(df=df, size=self.n)
    def densidad(x): return chi2.pdf(x, df)
    return datos, densidad

  def BS(self):
    """Genera datos con distribución BS y devuelve su densidad teórica."""
    u = np.random.uniform(size=self.n)
    y = np.copy(u)
    ind = np.where(u > 0.5)[0]
    y[ind] = np.random.normal(0, 1, size=len(ind))
    for j in range(5):
        ind = np.where((u > j * 0.1) & (u <= (j+1) * 0.1))[0]
        y[ind] = np.random.normal(j/2 - 1, 1/10, size=len(ind))

    def densidad(x):
      d = 0.5 * norm.pdf(x, 0, 1)
      for j in range(5):
        d += 0.1 * norm.pdf(x, j/2 - 1, 1/10)
      return d

    return y, densidad

  def t_student(self, df):
    """Genera datos con distribución t de Student y devuelve la densidad teórica."""
    datos = np.random.standard_t(df, size=self.n)
    def densidad(x): return t.pdf(x, df)
    return datos, densidad

  def uniforme(self, a=0, b=1):
    """Genera datos con distribución uniforme y devuelve la densidad teórica."""
    datos = np.random.uniform(low=a, high=b, size=self.n)
    def densidad(x): return uniform.pdf(x, loc=a, scale=b-a)
    return datos, densidad
  pass

class RegresionLinealSimple():
  """
  Clase para ajustar un modelo de regresión lineal simple y realizar inferencia estadística.
  Calcula parámetros estimados (pendiente y ordenada al origen), varianza, residuos, errores estándar,
  valores t, p-valores, intervalos de confianza y recta ajustada.
  """

  def __init__(self, x, y):
    self.x = np.array(x)
    self.y = np.array(y)
    self.n = len(self.x)
    self.gl = self.n - 2
    self.b1 = self.calcular_pendiente()
    self.b0 = self.calcular_ordenada()
    self.varianza = self.estimar_varianza()
    self.SE_b0, self.SE_b1 = self.calcular_errores_estandar()
    self.t_b0, self.t_b1 = self.calcular_t_obs()
    self.p_b0, self.p_b1 = self.calcular_p_valores()
    self.IC_b0, self.IC_b1 = self.calcular_intervalos_confianza()

  def calcular_pendiente(self):
    x_bar = np.mean(self.x)
    y_bar = np.mean(self.y)
    numerador = np.sum((self.x - x_bar) * (self.y - y_bar))
    denominador = np.sum((self.x - x_bar) ** 2)
    return numerador / denominador

  def calcular_ordenada(self):
    x_bar = np.mean(self.x)
    y_bar = np.mean(self.y)
    return y_bar - self.b1 * x_bar

  def recta_ajustada(self, x_valores):
    return self.b0 + self.b1 * x_valores

  def obtener_residuos(self):
    return self.y - self.recta_ajustada(self.x)

  def estimar_varianza(self):
    residuos = self.obtener_residuos()
    return np.sum(residuos**2) / self.gl

  def calcular_errores_estandar(self):
    x_bar = np.mean(self.x)
    Sxx = np.sum((self.x - x_bar)**2)
    SE_b1 = np.sqrt(self.varianza / Sxx) # Error estándar de beta1
    SE_b0 = np.sqrt(self.varianza * (1/self.n + x_bar**2 / Sxx)) # Error estándar de beta0
    return SE_b0, SE_b1

  def calcular_t_obs(self, hipotesis_b0=0, hipotesis_b1=0):
    t_b0 = (self.b0 - hipotesis_b0) / self.SE_b0
    t_b1 = (self.b1 - hipotesis_b1) / self.SE_b1
    return t_b0, t_b1

  def calcular_valor_critico(self, alpha=0.05):
    return stats.t.ppf(1 - alpha/2, df=self.gl)

  def calcular_p_valores(self, hipotesis_b0=0, hipotesis_b1=0):
    t_b0, t_b1 = self.calcular_t_obs(hipotesis_b0, hipotesis_b1)
    p_b0 = 2 * (1 - stats.t.cdf(abs(t_b0), df=self.gl))
    p_b1 = 2 * (1 - stats.t.cdf(abs(t_b1), df=self.gl))
    return p_b0, p_b1

  def calcular_intervalos_confianza(self, alpha=0.05):
    t_crit = self.calcular_valor_critico(alpha)
    IC_b0 = (self.b0 - t_crit * self.SE_b0, self.b0 + t_crit * self.SE_b0)
    IC_b1 = (self.b1 - t_crit * self.SE_b1, self.b1 + t_crit * self.SE_b1)
    return IC_b0, IC_b1

  def intervalo_confianza_esperanza(self, x_new, alpha=0.05):
    """
    Devuelve el intervalo de confianza para la media de Y dado x_new.
    """
    X = sm.add_constant(self.x)
    modelo = sm.OLS(self.y, X)
    resultado = modelo.fit()

    X_new = np.array([1, x_new])
    print(X_new)
    prediccion = resultado.get_prediction(X_new)
    ic = prediccion.conf_int(alpha=alpha)
    print(f"Intervalo de confianza para la esperanza de Y cuando x = {x_new}:")
    print(f"[{ic[0, 0]:.4f}, {ic[0, 1]:.4f}]")
    return ic[0]

  def intervalo_prediccion(self, x_new, alpha=0.05):
    """
    Devuelve el intervalo de predicción para un nuevo valor de Y dado x_new.
        """
    X = sm.add_constant(self.x)
    modelo = sm.OLS(self.y, X)
    resultado = modelo.fit()

    X_new = sm.add_constant(np.array([[x_new]]))
    prediccion = resultado.get_prediction(X_new)
    ip = prediccion.conf_int(obs=True, alpha=alpha)

    print(f"Intervalo de predicción para un nuevo Y cuando x = {x_new}:")
    print(f"[{ip[0, 0]:.4f}, {ip[0, 1]:.4f}]")
    return ip[0]

  def graficar_residuos_y_qqplot(self, x):
      y_ajustada = self.recta_ajustada(x)
      residuos = self.obtener_residuos()

      # Gráfico de residuos vs valores ajustados
      plt.scatter(y_ajustada, residuos, color='purple')
      plt.axhline(0, color='gray', linestyle='--')
      plt.xlabel("Valores ajustados (ŷ)")
      plt.ylabel("Residuos (r)")
      plt.title("Gráfico de residuos vs valores ajustados")
      plt.grid(True)
      plt.show()

      # QQ-Plot usando la clase Estimacion
      estimador = AnalisisDescriptivo(residuos)
      estimador.miqqplot()

  def __concluir_sobre_hipotesis(self, coeficiente='b1', hipotesis=0, alpha=0.05):
    t_obs_tuple = self.calcular_t_obs(hipotesis_b0=hipotesis, hipotesis_b1=hipotesis)
    p_valor_tuple = self.calcular_p_valores(hipotesis_b0=hipotesis, hipotesis_b1=hipotesis)
    intervalo_tuple = self.calcular_intervalos_confianza(alpha=alpha)
    if coeficiente == 'b1':
      t_obs = t_obs_tuple[1]
      p_valor = p_valor_tuple[1]
      IC = intervalo_tuple[1]
      estimado = self.b1
    elif coeficiente == 'b0':
      t_obs = t_obs_tuple[0]
      p_valor = p_valor_tuple[0]
      IC = intervalo_tuple[0]
      estimado = self.b0
    else:
      raise ValueError("El coeficiente debe ser 'b0' o 'b1'.")

    t_crit = self.calcular_valor_critico(alpha)

    print(f"\n--- Hipótesis sobre {coeficiente} ---")
    print(f"H₀: {coeficiente} = {hipotesis}")
    print(f"Estimación puntual: {estimado:.4f}")
    print(f"t observado: {t_obs:.4f}")
    print(f"t crítico (α = {alpha}): ±{t_crit:.4f}")
    print(f"p-valor: {p_valor:.4f}")
    print(f"Intervalo de confianza al {(1-alpha)*100:.0f}%: ({IC[0]:.4f}, {IC[1]:.4f})")

    # Conclusión por región de rechazo
    if abs(t_obs) > t_crit:
      print("➤ Conclusión (región de rechazo): Se rechaza H₀.")
    else:
      print("➤ Conclusión (región de rechazo): No se puede rechazar H₀.")

    # Conclusión por intervalo
    if IC[0] <= hipotesis <= IC[1]:
      print("➤ Conclusión (intervalo de confianza): El valor hipotético está dentro del intervalo.")
    else:
      print("➤ Conclusión (intervalo de confianza): El valor hipotético está fuera del intervalo.")

  def graficar(self, ax=None):
    if ax is None:
        fig, ax = plt.subplots()
    ax.scatter(self.x, self.y, color='blue')
    ax.plot(self.x, self.recta_ajustada(self.x), color='black')
    ax.set_title("Recta de regresión lineal")
    ax.set_xlabel("x")
    ax.set_ylabel("y")
  pass

class RegresionLinealMultiple:
  """
  Clase para ajustar un modelo de regresión lineal múltiple y realizar inferencia estadística.
  Calcula coeficientes estimados, varianza residual, residuos, errores estándar, valores t,
  p-valores, intervalos de confianza, matriz de varianza-covarianza y métricas de ajuste como R² y R² ajustado.
  Incluye herramientas para diagnóstico del modelo mediante gráficos y pruebas de significancia conjunta.
  """
  def __init__(self, X, y):
    self.X = np.array(X)
    self.y = np.array(y)
    self.n = len(self.y)
    self.k = self.X.shape[1]  # número de predictores
    self.gl = self.n - self.k - 1

    self.modelo = sm.OLS(self.y, self.X) #define el modelo de regresion lineal
    self.resultado = self.modelo.fit() #arma el esquema

    # Coeficientes
    self.betas = self.resultado.params

    # Errores estándar
    self.errors_estandar = self.resultado.bse

    # Estadísticos t
    self.t_values = self.resultado.tvalues

    # p-valores
    self.p_values = self.resultado.pvalues

    # Intervalos de confianza
    self.intervalos_confianza = self.resultado.conf_int() #calcula los intevalos de confianza para los betas

  def predecir(self, x_nuevos, alpha=0.05):
    X_nuevos = np.array(x_nuevos)
    y_ajustado = np.dot(x_nuevos, self.betas)

    prediccion = self.resultado.get_prediction(x_nuevos)
    ic = prediccion.conf_int(alpha=alpha)
    ip = prediccion.conf_int(obs=True, alpha=alpha)
    diccionario = {
    'res': [print(f"La recta ajustada es: {y_ajustado:.4f}")],
    'int_conf': [print(f"intervalo de confianza: [{ic[0, 0]:.4f}, {ic[0, 1]:.4f}]")],
    'int_pred': [print(f"intervalo de predicción: [{ip[0, 0]:.4f}, {ip[0, 1]:.4f}]")],
    }
    return diccionario

  def obtener_residuos(self):
    return self.resultado.resid

  def estimar_varianza(self):
    return self.resultado.mse_resid

  def mostrar_R2(self):
    r2 = self.resultado.rsquared
    r2_adj = self.resultado.rsquared_adj
    print(f"R²: {r2:.4f}")
    print(f"R² ajustado: {r2_adj:.4f}")
    return r2, r2_adj

  def calcular_intervalos_confianza(self, alpha=0.05): #calcula los intevalos de confianza para los betas con distinto alpha
    return self.resultado.conf_int(alpha=alpha)

  def __concluir_sobre_hipotesis(self, indice_coef, hipotesis=0, alpha=0.05):
    nombre = "Intercepto" if indice_coef == 0 else f"b{indice_coef}"
    estimado = self.betas[indice_coef]
    SE = self.errors_estandar[indice_coef]
    t_obs = self.t_values[indice_coef]
    p_valor = self.p_values[indice_coef]
    IC = self.intervalos_confianza[indice_coef]

    print(f"\n--- Hipótesis sobre {nombre} ---")
    print(f"H₀: {nombre} = {hipotesis}")
    print(f"Estimación puntual: {estimado:.4f}")
    print(f"p-valor: {p_valor:.4f}")
    print(f"Intervalo de confianza al {(1-alpha)*100:.0f}%: ({IC[0]:.4f}, {IC[1]:.4f})")

    if p_valor < alpha:
        print("➤ Conclusión (región de rechazo): Se rechaza H₀.")
    else:
        print("➤ Conclusión (región de rechazo): No se puede rechazar H₀.")

    if IC[0] <= hipotesis <= IC[1]:
        print("➤ Conclusión (intervalo de confianza): El valor hipotético está dentro del intervalo.")
    else:
        print("➤ Conclusión (intervalo de confianza): El valor hipotético está fuera del intervalo.")

  def resumen(self):
    print(self.resultado.summary())

  def graficar_residuos_y_qqplot_mult(self, x):
    betas = self.betas
    y_ajustada = np.dot(self.X, betas)
    residuos = self.obtener_residuos()

    # Gráfico de residuos vs valores ajustados
    plt.scatter(y_ajustada, residuos, color='purple')
    plt.axhline(0, color='gray', linestyle='--')
    plt.xlabel("Valores ajustados (ŷ)")
    plt.ylabel("Residuos (r)")
    plt.title("Gráfico de residuos vs valores ajustados")
    plt.grid(True)
    plt.show()

    # QQ-Plot usando la clase Estimacion
    estimador = AnalisisDescriptivo(residuos)
    estimador.miqqplot()
  pass